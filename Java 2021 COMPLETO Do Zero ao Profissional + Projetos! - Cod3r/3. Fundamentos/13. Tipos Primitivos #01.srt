1
00:00:00,340 --> 00:00:07,500
Agora mais aos falados tipos primitivos na linguagem Java ou seja os blocos de construção em termos

2
00:00:07,500 --> 00:00:13,770
de dados e como você vai construir dados mais complexos dentro do seu sistema você vai definir um produto

3
00:00:13,770 --> 00:00:14,600
um cliente.

4
00:00:14,600 --> 00:00:16,360
Você vai definir um data.

5
00:00:16,410 --> 00:00:22,740
Tudo isso requer que outros dados preliminares tipos mais básicos estejam disponíveis nas linguagens

6
00:00:22,740 --> 00:00:29,660
como é o caso de títulos numéricos caracteres por exemplo é um tipo mais básico você tem por exemplo

7
00:00:29,660 --> 00:00:31,690
baladeiro o falso booleano.

8
00:00:31,710 --> 00:00:37,170
Então vou discutir com vocês na sala teórica sobre os tipos primitivos de Java e na próxima aula nós

9
00:00:37,170 --> 00:00:38,940
vamos trabalhar a prazo com esses tipos.

10
00:00:38,940 --> 00:00:39,320
Tá bom.

11
00:00:39,570 --> 00:00:50,310
Então só pra gente colocar aqui ou trabalhar na sala com os tipos primitivos x erros na linguagem Java

12
00:00:50,400 --> 00:00:51,080
e Java.

13
00:00:51,080 --> 00:00:58,620
Nós temos oito tipos primitivos então nós temos oito tipos primitivos da linguagem Java tem aqui um

14
00:00:58,620 --> 00:01:00,780
exemplo bem básico por exemplo.

15
00:01:00,930 --> 00:01:06,600
Vamos supor que você quer criar um objeto que represente o mandato do seu sistema certo.

16
00:01:06,600 --> 00:01:12,670
Você provavelmente vai ter algum tipo primitivo algum valor que vai representar um dia por exemplo o

17
00:01:12,670 --> 00:01:18,760
dia 21 do mês 4 do ano de 2021.

18
00:01:18,870 --> 00:01:24,120
Então aqui nós temos um inteiro pra apresentar um dia inteiro para representar um mês o outro inteiro

19
00:01:24,140 --> 00:01:25,510
pra representar um ano.

20
00:01:25,600 --> 00:01:34,590
E aí você coloca e colocar também hora minuto segundo e você tem aqui por exemplo 17 horas 53 minutos

21
00:01:34,650 --> 00:01:36,390
e 22 segundos.

22
00:01:36,450 --> 00:01:43,520
Então você tem um inteiro aqui um inteiro aqui um inteiro um certo você tem seis inteiros ou seja tipos

23
00:01:43,530 --> 00:01:46,950
mais básicos pra representar um objeto mais complexo que a data.

24
00:01:47,400 --> 00:01:53,250
Então é exatamente em cima desses tipos básicos da linguagem que eu quero trabalhar com você está em

25
00:01:53,250 --> 00:02:00,930
Java nós temos oito tipos sendo que desses oito tipos 6 são títulos numéricos e os outros dois são tipos

26
00:02:00,930 --> 00:02:04,580
diferentes de números que é Booleana caractere já falar sobre eles.

27
00:02:04,650 --> 00:02:11,600
Então nós temos aqui dois tipos e nós temos outros seis tipos que representam valores numéricos.

28
00:02:12,060 --> 00:02:13,060
Apagar isso aqui.

29
00:02:13,170 --> 00:02:18,300
Pronto vamos lá dos seis tipos que representam valores numéricos.

30
00:02:18,300 --> 00:02:26,080
Eu tenho quatro deles que representam valores inteiros em dia que eu tenho o bit que é o menor deles.

31
00:02:26,460 --> 00:02:33,210
Eu tenho sorte eu tenho muitos e eu tenho por homem certo.

32
00:02:33,330 --> 00:02:41,220
Qual a diferença desses quatro dígitos numéricos inteiros do Java a diferença é só o tamanho o bit ele

33
00:02:41,220 --> 00:02:44,600
é a representação de um único bairro ou seja um byte.

34
00:02:44,890 --> 00:02:51,540
Colocar uma bolinha aqui colocar um bolinha aqui colocar Olhem aqui uma bolinha aqui só para a gente

35
00:02:51,540 --> 00:02:52,340
desenhar.

36
00:02:52,500 --> 00:02:57,300
Colocar aqui os valores como qualquer empresa que representa um baixo aqui.

37
00:02:57,320 --> 00:03:02,760
Sorte são dois bytes 24 bits é o dobro e o login.

38
00:03:03,000 --> 00:03:05,820
São 8 bits ou seja um bit.

39
00:03:06,000 --> 00:03:10,940
Depois sorte é o dobro do baixo ou seja 2 bytes o índice é o dobro do xote.

40
00:03:10,950 --> 00:03:13,900
São 4 bytes e o longa é o dobro do Hindi.

41
00:03:13,980 --> 00:03:20,430
São 8 bits ou seja a diferença desses quatro tipos numéricos inteiros é basicamente a capacidade de

42
00:03:20,430 --> 00:03:21,660
armazenamento.

43
00:03:21,660 --> 00:03:29,100
Se você pegar por exemplo aqui o exemplo do mais baixo como sendo o menor tipo inteiro em Java ele armazena

44
00:03:29,190 --> 00:03:39,810
um intervalo de menos cento e 28 até mais cento e 27 certo.

45
00:03:39,840 --> 00:03:41,620
Então esse é o rígido bit.

46
00:03:41,630 --> 00:03:47,540
Se eu pegar por exemplo no caso do xote o choque ele armazena mais ou menos.

47
00:03:47,560 --> 00:03:55,960
Não vou colocar aqui o valor exato até para ajustar o valor exato mais é mais ou menos 32 mil 760 e

48
00:03:56,100 --> 00:03:56,880
707.

49
00:03:56,880 --> 00:04:03,030
Só que o negativo sempre é um número a mais positivo sempre número a menos já que o zero está no eixo

50
00:04:03,030 --> 00:04:05,970
positivo ou seja ele pega o arranjo de vídeo na metade.

51
00:04:05,970 --> 00:04:13,780
Você tem mais ou menos um intervalo de 32 meses você paga que o índice é mais ou menos 2 bilhões 2 bilhões

52
00:04:13,800 --> 00:04:17,590
alguma coisa 7 700 alguma coisa login e ao número bem grande aí.

53
00:04:17,970 --> 00:04:25,530
Ou seja em outras palavras a diferença que você tem desses quatro tipos inteiros numéricos é a capacidade

54
00:04:25,530 --> 00:04:31,410
dele estar aqui para falar um pouco mais sobre isso e além disso nós temos mais dois títulos com ponto

55
00:04:31,410 --> 00:04:34,410
flutuante que é o que a gente já viu até agora.

56
00:04:34,450 --> 00:04:41,070
Que bom que é o maior do tipo e nós temos o Flores falou que também é um tipo com ponto flutuante até

57
00:04:41,070 --> 00:04:46,800
o nome já deixa claro isso é o da boa ele é o dobro do Floyd por isso o nome dado disse é o dobro da

58
00:04:46,800 --> 00:04:53,110
capacidade do foguete enquanto o fortim tem uma capacidade de 4 bits.

59
00:04:53,160 --> 00:04:54,740
O água tem uma capacidade de 8.

60
00:04:54,740 --> 00:05:01,010
Então o w tem 8 bits e o Focus tem 4 bits certo ou seja o dobro da capacidade.

61
00:05:01,010 --> 00:05:10,740
Você sabe que um bit set só para deixar claro aqui embaixo corresponde a 8 bits 7 bit 1 0 ou 1.

62
00:05:10,980 --> 00:05:21,860
Então dentro da formação de um número em Java nós temos aqui 58 N 1 2 3 4 5 6 7 8.

63
00:05:21,860 --> 00:05:27,760
O primeiro dígito que é esse distro aqui ele vai apresentar se o número é positivo ou negativo.

64
00:05:27,800 --> 00:05:35,750
E aí os outros vai ter os números zeros e uns por exemplo tem aqui 0 1 0 1 0 1 por exemplo o que vai

65
00:05:35,750 --> 00:05:41,660
ser um número e aqui o dígito mais significativo vai dizer se for 0 vai ser positivo ou negativo.

66
00:05:41,660 --> 00:05:42,950
Não estou lembrado exatamente.

67
00:05:43,430 --> 00:05:46,300
Acho que 0 a Positivo e 1 seria negativo.

68
00:05:46,340 --> 00:05:52,620
Mas o fato é que o mais significativo representa o sinal e o resto representa o valor numérico.

69
00:05:52,620 --> 00:05:55,040
Isso aqui seria o correspondente ao bit.

70
00:05:55,040 --> 00:06:01,820
Se você pegar pelo choque olhe para o índice se você pegar os outros por sorte ou o que vai acontecer

71
00:06:01,820 --> 00:06:02,090
aqui.

72
00:06:02,100 --> 00:06:07,780
Isso vai aumentar bastante cara a cara e você vai ter muitos outros bits aqui pra representar o número

73
00:06:07,790 --> 00:06:15,200
seja a capacidade vai aumentar bastante e no caso do Forte do dado o que nós temos é um número que suporta

74
00:06:15,200 --> 00:06:21,050
ponto flutuante dentro desse espaço que vai armazenar os números do zero sozinhos você vai ter um número

75
00:06:21,050 --> 00:06:26,000
com casas decimais e os outros dois tipos primitivos em Java.

76
00:06:26,000 --> 00:06:36,510
Nós temos o Char que é o caractere certo quem representa uma letra e você tem o Bulletin Bulent que

77
00:06:36,520 --> 00:06:46,640
representa o verdadeiro falso obrigatoriamente em Java Gülen sempre será falso certo falso ou verdadeiro

78
00:06:46,640 --> 00:06:48,230
ou falso certo.

79
00:06:48,400 --> 00:06:53,310
Tudo é letra minúscula que eu coloquei letra maiúscula até mudar aqui para colocar em letra minúscula

80
00:06:53,320 --> 00:06:54,000
que fica melhor.

81
00:06:54,320 --> 00:07:03,790
Então nós temos aqui falso e tu não existe a possibilidade de outras linguagens como por exemplo JavaScript.

82
00:07:03,880 --> 00:07:10,740
Ele acaba permitindo que outros valores represente o verdadeiro falso por exemplo.

83
00:07:11,050 --> 00:07:16,820
Zero vai ser convertido pra falso qualquer outro número pra verdadeiro monstrinho vazia.

84
00:07:16,830 --> 00:07:20,130
Nenhuma dessas conversões em Java não sempre é falso.

85
00:07:20,170 --> 00:07:22,930
Outro verdadeiro ou falso é o chá.

86
00:07:22,930 --> 00:07:27,660
Ele é um caractere delimitado por casco simples pode ser a letra A.

87
00:07:27,850 --> 00:07:33,790
Pode ser por exemplo um espaço em branco também é considerado como caractere pode ser um símbolo por

88
00:07:33,790 --> 00:07:40,240
exemplos e coloca aqui uma interrogação entre aspas simples apresenta um chá e obviamente um conjunto

89
00:07:40,240 --> 00:07:43,440
de caracteres formar as palavras e aí você vai colocar.

90
00:07:43,750 --> 00:07:50,440
Esse conjunto maior leva uma frase textos mais do tipo básico da linguagem para representar caracteres

91
00:07:50,440 --> 00:07:52,490
alfanumérico vai se encaixar inclusive.

92
00:07:52,510 --> 00:07:58,020
Você também tem a possibilidade no chat representar valores numéricos colocar por exemplo número um

93
00:07:58,330 --> 00:08:00,350
só com número um entre aspas.

94
00:08:00,370 --> 00:08:02,280
Ele é um chá e não um bolo inteiro.

95
00:08:02,290 --> 00:08:08,640
Tá certo então nós temos aqui o bule verdadeiro o falso caractere que representa um símbolo 7.5 para

96
00:08:08,650 --> 00:08:14,140
dizer a interrogação pode ser uma letra ou letra maiúscula pode ser um número delimitado por aspas simples

97
00:08:14,170 --> 00:08:20,500
mas temos seis tipos numéricos quatro tipos que apresentam valores inteiros a única diferença entre

98
00:08:20,500 --> 00:08:21,790
eles é o tamanho.

99
00:08:21,790 --> 00:08:26,070
E nós temos dois tipos que representam valores com ponto flutuante.

100
00:08:26,080 --> 00:08:32,020
Uma outra observação importante é o seguinte sempre que você digita um valor literal que é o valor literal

101
00:08:32,020 --> 00:08:34,840
e o próprio número então você cria uma variável.

102
00:08:34,840 --> 00:08:44,590
Por exemplo se aquilo que a gente já fez e coloca que colocam a variável vai se a recebe o valor 3 certo.

103
00:08:44,740 --> 00:08:50,180
Esse valor 3 aqui ele é um valor literal e o número que você colocou diretamente no seu código.

104
00:08:50,530 --> 00:08:55,580
Quando você coloca um valor inteiro ele por padrão vai ser o tipo.

105
00:08:56,050 --> 00:09:02,860
Então por padrão se você quer criar um inteiro ele vai representar o tipo certo ou seja qualquer literal

106
00:09:02,890 --> 00:09:04,510
inteiro dentro de Java.

107
00:09:04,660 --> 00:09:06,620
Por padrão vai ser do tipo int.

108
00:09:06,670 --> 00:09:16,600
Da mesma forma que qualquer literal se você colocar aqui um bom d carta na mesma sintaxe que a mesma

109
00:09:16,600 --> 00:09:17,450
raiz latina.

110
00:09:17,820 --> 00:09:23,440
Então B recebe o valor por exemplo de 3.

111
00:09:23,440 --> 00:09:26,740
Ponto 2 0 1 pontinho 3 ponto 2.

112
00:09:26,740 --> 00:09:33,820
Esse literal aqui por padrão será do tipo W ou seja qualquer literal com ponto flutuante será do tipo

113
00:09:33,820 --> 00:09:37,410
W é qualquer literal inteiro será do tipo.

114
00:09:37,660 --> 00:09:44,320
Então esses são os dois valores que são usados por padrão em Java literais inteiros são literais com

115
00:09:44,320 --> 00:09:46,200
ponto flutuante são Bamboo.

116
00:09:46,540 --> 00:09:51,340
Outra observação importante que vá acontecer mais à frente mais eu não vou me aprofundar muito nessa

117
00:09:51,340 --> 00:09:57,490
aula o seguinte Mei provavelmente vai existir situações que você vai precisar converter um número em

118
00:09:57,500 --> 00:10:03,490
outro você vai precisar pagar uma variável Long e atribuir uma variável inteira apanhar a variável Short

119
00:10:03,510 --> 00:10:04,900
colocado em junho.

120
00:10:05,270 --> 00:10:11,260
Então uma das regras básicas é com relação a esse tipo de conversão é que sempre que você pegar um tipo

121
00:10:11,260 --> 00:10:16,990
menor e tentar converter para um tipo maior isso aqui normalmente vai ser tranquilo porque tudo o que

122
00:10:16,990 --> 00:10:21,760
cabe aqui dentro do tipo menor vai caber aqui no time maior.

123
00:10:21,760 --> 00:10:27,430
Ou seja essa conversão mais simples que eu já baixaram com a versão mais simples a não ser que você

124
00:10:27,430 --> 00:10:32,370
esteja convertendo o tipo que tem casas decimais para um tipo inteiro aí você vai pela informação já

125
00:10:32,400 --> 00:10:38,260
vai reclamar mas sempre que você sai de um tipo que tem uma capacidade maior ou menor de armazenamento

126
00:10:38,260 --> 00:10:44,440
pra um que tem uma capacidade maior o Java vai entender que tudo o que está dentro desse tipo vai caber

127
00:10:44,440 --> 00:10:46,480
dentro desse outro tipo e não vai ser problema.

128
00:10:46,930 --> 00:10:53,050
Mas como você faz o contrário isso pode ser um problema certo você tem que ser mais explícito nesse

129
00:10:53,050 --> 00:10:58,050
caso porque nem tudo o que cabe aqui dentro vai caber nesse outro tipo que menor.

130
00:10:58,300 --> 00:11:03,490
Você pode perder a informação então isso é algo pra considerar o fato de você ter múltiplos títulos

131
00:11:03,490 --> 00:11:09,160
dentro da linguagem Java e fazer com que você eventualmente precise converter o tipo em outro da mesma

132
00:11:09,160 --> 00:11:16,240
forma que aconteceu aqui esse é um cenário que 3 é um tipo inteiro você está colocando 3 dentro de uma

133
00:11:16,240 --> 00:11:18,950
variável do tipo W 0.

134
00:11:19,120 --> 00:11:24,160
Nesse caso vai haver uma conversão mas mais exatamente vai acontecer o que você tem um tipo menor que

135
00:11:24,160 --> 00:11:31,810
está sendo atribuído para um tipo maior então no caso aqui seria o inglês e aqui seria o W.

136
00:11:32,140 --> 00:11:38,470
Então nesse caso eu consigo sim entrar tem de mas eu não vou conseguir colocar um do INSS por conta

137
00:11:38,770 --> 00:11:43,770
do tamanho da capacidade de armazenamento mas é um tema que vou falar um pouco mais à frente que nao

138
00:11:43,850 --> 00:11:49,810
e se eu quiser ser mais detalhista que eu poderia em vez de o lo aqui já que esse tipo literalmente

139
00:11:49,810 --> 00:11:53,900
Pointe aqui eu vou colocar também pra ser do tipo.

140
00:11:54,050 --> 00:12:01,780
Fica Gear S3 e da B recebe 3 2 lembrando que os literais tem um valor padrão no caso do ponto flutuante

141
00:12:01,800 --> 00:12:07,840
e o dobro no caso de literais inteiro são do tipo II e a diferença do tamanho é a última coisa que eu

142
00:12:07,840 --> 00:12:16,780
quero falar o seguinte existe uma diferença de tamanho você tem baixo você tem sorte você tem o inglês

143
00:12:16,930 --> 00:12:22,630
e você tem um longo são os quatro tipos inteiros e como eu falei anteriormente você tem um baixo é o

144
00:12:22,630 --> 00:12:23,450
nome é baixo.

145
00:12:23,530 --> 00:12:29,040
Você tem sorte com o sendo dois bytes você tem um entre 4 bytes log 8 bit.

146
00:12:29,080 --> 00:12:36,550
é uma pergunta recorrente em todos esses anos de ensino é o seguinte chamado e eu tenho eu quero armazenar

147
00:12:36,550 --> 00:12:43,660
por exemplo a quantidade de anos que um determinado funcionário pertence à empresa então há de convir

148
00:12:43,660 --> 00:12:54,640
que dentro do barco você tem um intervalo de menos 127 menos 127 até mais na verdade menos 128 até mais

149
00:12:54,910 --> 00:12:56,560
cento e 27.

150
00:12:56,560 --> 00:13:02,350
Há de convir que nesse intervalo vai caber assim a quantidade de horas que o funcionário pertence à

151
00:13:02,350 --> 00:13:04,210
empresa ou que trabalhe na empresa.

152
00:13:04,220 --> 00:13:09,760
Ninguém vai trabalhar mais do que esse e lá 60 anos vem de um empresa então dá com folga para armazenar

153
00:13:09,760 --> 00:13:10,380
dados aqui.

154
00:13:10,390 --> 00:13:18,010
Beleza dá assim mas eu não acho que esse tipo de otimização a otimizar no micro ali fazem com que eu

155
00:13:18,010 --> 00:13:23,410
uso exatamente o tipo de dados que vai dar o menor consumo de memória esse tipo de otimização muito

156
00:13:23,410 --> 00:13:27,160
provavelmente não vai fazer diferença nenhuma no seu sistema.

157
00:13:27,430 --> 00:13:34,300
Então nesse cenário mesmo senão uma quantidade pequena que só sei lá que vai pegar poucas dezenas ali

158
00:13:34,300 --> 00:13:40,930
de anos eu usaria valores inteiros por padrão porque esse tipo de otimização na prática não vai fazer

159
00:13:40,930 --> 00:13:46,360
muita diferença no seu sistema então alguns alunos acabam pântano isso então outros tipos de otimização

160
00:13:46,360 --> 00:13:52,300
vão acabar trazendo mais benefícios para sua aplicação do que propriamente você ficar trocando os tipos

161
00:13:52,300 --> 00:13:58,620
das variáveis primitivas porque esse tipo de dado ocupa muito pouco espaço dentro de uma aplicação grande

162
00:13:58,630 --> 00:14:05,260
certo mais se você trabalhar com milhares e milhares de dados de determinado tipo voce tem como otimizar.

163
00:14:05,290 --> 00:14:09,910
Aí sim eu acho que compensa mas no geral eu acho que esse tipo de otimização não vai trazer grandes

164
00:14:09,910 --> 00:14:11,670
benefícios para sua aplicação.

165
00:14:11,680 --> 00:14:17,800
Então dito isso se você tiver realmente querendo trabalhar com dados extremamente otimizados se for

166
00:14:17,800 --> 00:14:23,650
um cenário especifico ok eu até trocaria mais num cenário reagiu acabo escolhendo boa parte do tempo

167
00:14:23,650 --> 00:14:30,290
trabalhar com valores inteiros e como eu preciso trabalhar com valores grandes aí sim eu coloco valores

168
00:14:30,330 --> 00:14:37,570
coloque uma vez em estava definindo lá o fundo um fundo de investimento a gente colocou um valor inteiro

169
00:14:37,930 --> 00:14:42,810
que dá até 2 bilhões e chegou um momento que estava dando problema a gente descobriu porque tinha fundos

170
00:14:42,850 --> 00:14:46,630
de investimento com valores maiores do que esse e a gente trocou pra Long.

171
00:14:46,630 --> 00:14:49,160
O problema sumiu é problema de precisão.

172
00:14:49,250 --> 00:14:51,220
Estava trocando lá um determinado valor.

173
00:14:51,670 --> 00:14:56,810
Então é importante você escolher bem os chips no momento certo mas pelo padrão acabo usando o índice

174
00:14:56,860 --> 00:14:58,690
eu vou trabalhar com valores inteiros.

175
00:14:58,720 --> 00:15:02,890
Então pensar na aproximação nós vamos trabalhar com a parte prática dos chips primitivos a gente vai

176
00:15:02,890 --> 00:15:07,630
conhecer basicamente todos os tipos primitivos de usar ele é além do que a gente viu aqui vai ter algumas

177
00:15:07,630 --> 00:15:12,160
regras interessantes quando a gente vai trabalhar com os literais como eu falei pra vocês mas é melhor

178
00:15:12,160 --> 00:15:14,440
mostrar isso na prática então na próxima além de encontra.
