F107 - 
Introdução ao Modulo
Fundamentos -> Arrays e Collections;

F108 - 
Array
Lista numerada;
Estrutura de tamanho fixo, antes de gera-lo precisa informar o tamanho; estrutura estatica; passivel de realocar as informações array maiores, mas não aumentar o array atual;
estrutura unidimensional;
homogenêo -> um array tem um só tipo de dado, array de interiros, array de doubles;

double [] a = new double [6]; -> reservo um espaço na memoria informando ser um array (double [] a) que receberá(=) uma construção de arrays de decimais com 6 posições(new double [6]);

a[2] = 10; inserir o valor 10.0 na posição 2 do array a[];
a[0] = 9.2;

System.out.println(a[5]); acessar a quinta posição do array;

acesso a notação.
a._____  -> habilitado;
a[2].    -> não habilitado;

não existe matriz em JAVA, então para simular a mesma, se usa Array dentro de array;

double [][] -> array bidimensional;
double [][][] -> array tridimensional;
e assim por diante....

F109 - 
Praticando os conceitos de array;
.length -> se tratando de arrays é um atributo;

F110 - 
Foreach; -> para cada;
estrutura do foreach;
for (double nota : notas) {//foreah
	System.out.print(nota + " ");			
}

F111 - 
Desafio Array;
F112 - 
Sucesso - Desafio Array;
'ctrl shift o' -> limpar advertência;

F113 - 
Matriz;
retorno de arrays com foreach;

F114 - 
conceito de igualdade dentro de objetos no JAVA;
difrença entre procurar igualdade entre dados e endereço de memoria;
metodo presente em todos os objetos e Classes(instanciadas) em JAVA -> .equals;
equals / hashcode
conjunto -> hashset

equals -> retorna boolean(true ou false);
hashcode -> retorna int;

como equals é de certa forma lento ao realizar buscas;
é usado primeiro o hashcode para diminuir a quatidade de resultados de buscar usando uma caracteristica mais especifica;
e o que o hashcode separou será aplicado o equals para dar acabemento e precisão a busca;

equals <-> hashcode

F115 - 
equals na prática;
instanceof
hashcode ficará para o fim do módulo;

F116 - 
conceitalização de collections;
estrutura de como organizar os dados;
tipos:

SET- se assemelha a um conjunto;
►Não ordenado (por padrão);
►Não indexado;
►Não aceita repetição

LIST- se assemelha a uma lista (array)
►Idexada;
►Aceita repetição;

MAP- se assemelha uma tabela de duas colunas; a chave é tipo SET e valor é tipos LIST;
►Chave/Valor;
►Chave não aceita repetição;
►Valor aceita repetição;

QUEUE - fila
►Implementa fila;
►First In / First Out (FIFO);

STACK-
►Implementa pilha(Stack);
►Last In / First Out (LIFO)

add - adiciona dados;
size() - metodo de tamanho da collection;

F117 -
SEt na prática;
SET- conjunto 
►Pode ser heterogêneo;(multiplos tipos);
►Pode ser homogêneo;(mono tipos);
►Não aceita obj duplicados;(objets com o mesmo equals ou mesmo hashcode);
►Pode ser ordenado;
►Não é indexado;
♦HashSet;

como calar as advertências;

F118-
SET homogêneo;
Set<String> lista =  new HashSet<String>(); ->  tradicional
Set<String> lista =  new HashSet<>();  -> operador diamond
SortedSet<String> listaAprovados =  new TreeSet<>();//respeita a ordem de adição;
______________________________________________________________________________________________________________________

